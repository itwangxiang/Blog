[{"categories":["生活"],"content":"是用来规划人生财务的一种工具 ","date":"2022-01-09","objectID":"/insurance/:0:0","tags":["保险","常识"],"title":"保险常识","uri":"/insurance/"},{"categories":["生活"],"content":"分类 社会保险 社会保障制度的一个最重要的组成部分 养老保险 医疗保险 失业保险 工伤保险 生育保险 商业保险 通过订立保险合同运营，以营利为目的的保险形式，由专门的保险企业经营 商业保险关系是由当事人自愿缔结的合同关系，投保人根据合同约定，向保险公司支付保险费，保险公司根据合同约定的可能发生的事故因其发生所造成的财产损失承担赔偿保险金责任，或者当被保险人死亡、伤残、疾病或达到约定的年龄、期限时承担给付保险金责任 – 百度 注意：任何商业保险，都是通过合同来走理赔，任何合同范围外的不陪，所有一定仔细看合同，不要轻易相信代理人的话 ","date":"2022-01-09","objectID":"/insurance/:0:1","tags":["保险","常识"],"title":"保险常识","uri":"/insurance/"},{"categories":["生活"],"content":"种类 人身保险 以人的寿命和身体为保险标的的保险 人寿保险 - 陪付受益人 人身意外伤害保险 - 陪付受益人或自己 健康险 重疾险 - 陪付自己 医疗险 - 陪付自己 防癌险 - 陪付自己 财产保险 以财产或利益为保险标的保险 ","date":"2022-01-09","objectID":"/insurance/:0:2","tags":["保险","常识"],"title":"保险常识","uri":"/insurance/"},{"categories":["生活"],"content":"其他常识 商业保险 在选择保险时，只需要关注产品是否符合自身的需求即可，无需关注公司的大小，因为国家管控，任何保险公司都非常稳定。 重疾险 次数 单次 多次 分组多次 不分组多次 级别 重症 中症 轻症 豁免 - 即投保人或被投保人被理赔过一次，无需再交后续保费 推荐 - 50万 意外险 + 300万医疗险 + 100 定期寿险 + 50 万重疾险 ","date":"2022-01-09","objectID":"/insurance/:0:3","tags":["保险","常识"],"title":"保险常识","uri":"/insurance/"},{"categories":["后端"],"content":"结构 ","date":"2020-09-23","objectID":"/spring-cloud/:1:0","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["后端"],"content":"Eureka 微服务注册表可实现弹性的中间层负载平衡和故障转移。. 微服务发现框架 Eureka Client：负责将这个服务的信息注册到Eureka Server中 Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号 ","date":"2020-09-23","objectID":"/spring-cloud/:1:1","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["后端"],"content":"Feign 使编写Java HTTP客户端更加容易 简化微服务之间的请求代码 ","date":"2020-09-23","objectID":"/spring-cloud/:1:2","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["后端"],"content":"Ribbon Ribbon 是一个进程间通信（远程过程调用）库，具有内置的软件负载平衡器。主要使用模型涉及具有各种序列化方案支持的REST调用 负载均衡工具 场景： 请求一个服务（有多个主机），可以均衡的请求 ","date":"2020-09-23","objectID":"/spring-cloud/:1:3","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["后端"],"content":"Hystrix Hystrix 是一个延迟和容错库，旨在隔离对远程系统，服务和第三方库的访问点，停止级联故障，并在不可避免发生故障的复杂分布式系统中实现弹性。 熔断器 雪崩：因某个请求失败而影响其他微服务，最终导致真个系统崩溃 熔断：隔离请求服务，将其失败不在影响其他服务 降级：请求失败后，采用备选方案处理 ","date":"2020-09-23","objectID":"/spring-cloud/:1:4","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["后端"],"content":"Zuul Zuul是一项网关服务，可提供动态路由，监视，弹性，安全性等 微服务网关 任何请求通过该网关转发至对应的服务 ","date":"2020-09-23","objectID":"/spring-cloud/:1:5","tags":["spring cloud","架构"],"title":"Spring cloud 微服务架构","uri":"/spring-cloud/"},{"categories":["数据库"],"content":"Mongodb ","date":"2020-03-14","objectID":"/mongodb/:0:0","tags":["mongodb"],"title":"Mongodb 常用命令","uri":"/mongodb/"},{"categories":["数据库"],"content":"常用命令 ","date":"2020-03-14","objectID":"/mongodb/:1:0","tags":["mongodb"],"title":"Mongodb 常用命令","uri":"/mongodb/"},{"categories":["数据库"],"content":"aggregate 求和 db.app_log.aggregate([ { $match: { userId: \"kim\", type: \"use\" } }, { $group: { _id: {}, total: { $sum: \"$useTime\" } } }, { $project: {_id: 0, total: 1}} ]) ","date":"2020-03-14","objectID":"/mongodb/:1:1","tags":["mongodb"],"title":"Mongodb 常用命令","uri":"/mongodb/"},{"categories":["数据库"],"content":"安装 sudo apt-get install mysql-server mysql-client ","date":"2020-02-13","objectID":"/mysql/:1:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"查看端口 sudo netstat -tap | grep mysql ","date":"2020-02-13","objectID":"/mysql/:2:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"设置初始密码 sudo mysql_secure_installation ","date":"2020-02-13","objectID":"/mysql/:3:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"登录 mysql -u root -ppassword ","date":"2020-02-13","objectID":"/mysql/:4:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"常用SQL -- 设置密码安全等级 setglobalvalidate_password_policy=0;-- 创建库 CreateDATABASEIFNOTEXISTS`todev_dev`defaultcharsetutf8COLLATEutf8_general_ci;-- 设置 todev_dev 访问密钥 -- create user `todev_dev` identified by '111111'; -- grant all privileges on `todev_dev`.* to `todev_dev`@`%` identified by '111111'; ALTERUSER'todev_dev'@'%'IDENTIFIEDBY'111111'; ","date":"2020-02-13","objectID":"/mysql/:5:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"常见问题 ","date":"2020-02-13","objectID":"/mysql/:6:0","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["数据库"],"content":"无法远程连接 ## 打开配置文件 vi /etc/mysql/mysql.conf.d/mysqld.cnf ## 注释 bind-address #bind-address = 127.0.0.1 ## 重启 service mysql restart ","date":"2020-02-13","objectID":"/mysql/:6:1","tags":["mysql"],"title":"MySQL 常用命令","uri":"/mysql/"},{"categories":["开发"],"content":" 官方文档 - en / zh-cn 惯用语法 - en / zh-cn ","date":"2019-11-05","objectID":"/kotlin/:0:0","tags":["kotlin","语法"],"title":"Kotlin 常用语法","uri":"/kotlin/"},{"categories":["开发"],"content":"基础 ","date":"2019-11-05","objectID":"/kotlin/:1:0","tags":["kotlin","语法"],"title":"Kotlin 常用语法","uri":"/kotlin/"},{"categories":["开发"],"content":"基础语法 包 package my.demo import kotlin.text.* 函数 fun sum(a: Int, b: Int): Int { return a + b } //表达式作为函数体，返回类型自动推断 fun sum(a: Int, b: Int) = a + b //无返回值的函数 fun printSum(a: Int, b: Int): Unit { println(\"sum of $aand $bis ${a + b}\") } //Unit 返回类型可以省略 fun printSum(a: Int, b: Int) { println(\"sum of $aand $bis ${a + b}\") } 变量 //定义只读局部变量使用 val 。只能赋值一次 val a: Int = 1 // 立即赋值 val b = 2 // 自动推断出 `Int` 类型 val c: Int // 如果没有初始值类型不能省略 c = 3 // 明确赋值 //可重复赋值的变量使用 var 关键字 var x = 5 // 自动推断出 `Int` 类型 x += 1 注解 // 这是一个行注释 /* 这是一个多行的 块注释。 */ 字符串模板 var a = 1 // 模板中的简单名称： val s1 = \"a is $a\" a = 2 // 模板中的任意表达式： val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\" 条件表达式 fun maxOf(a: Int, b: Int): Int { if (a \u003e b) { return a } else { return b } } fun maxOf(a: Int, b: Int) = if (a \u003e b) a else b 空值与 null 检测 //当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空 //如果 str 的内容不是数字返回 null： fun parseInt(str: String): Int? { // …… } //使用返回可空值的函数 fun printProduct(arg1: String, arg2: String) { val x = parseInt(arg1) val y = parseInt(arg2) // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null if (x != null \u0026\u0026 y != null) { // 在空检测后，x 与 y 会自动转换为非空值（non-nullable） println(x * y) } else { println(\"'$arg1' or '$arg2' is not a number\") } } is 类型检查与自动类型转换 //is 运算符检测一个表达式是否某类型的一个实例。 //如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 fun getStringLength(obj: Any): Int? { if (obj is String) { // `obj` 在该条件分支内自动转换成 `String` return obj.length } // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null } for 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (item in items) { println(item) } val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (index in items.indices) { println(\"item at $indexis ${items[index]}\") } while 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") var index = 0 while (index \u003c items.size) { println(\"item at $indexis ${items[index]}\") index++ } when 表达式 fun describe(obj: Any): String = when (obj) { 1 -\u003e \"One\" \"Hello\" -\u003e \"Greeting\" is Long -\u003e \"Long\" !is String -\u003e \"Not a string\" else -\u003e \"Unknown\" } range 范围 //使用 in 运算符来检测某个数字是否在指定区间内 val x = 10 val y = 9 if (x in 1..y+1) { println(\"fits in range\") } //检测某个数字是否在指定区间外 val list = listOf(\"a\", \"b\", \"c\") if (-1 !in 0..list.lastIndex) { println(\"-1 is out of range\") } if (list.size !in list.indices) { println(\"list size is out of valid list indices range, too\") } //区间迭代: for (x in 1..5) { print(x) } //数列迭代 for (x in 1..10 step 2) { print(x) } println() for (x in 9 downTo 0 step 3) { print(x) } Collections //对集合进行迭代 for (item in items) { println(item) } //使用 in 运算符来判断集合内是否包含某实例 when { \"orange\" in items -\u003e println(\"juicy\") \"apple\" in items -\u003e println(\"apple is fine too\") } //使用 lambda 表达式来过滤（filter）与映射（map）集合 val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\") fruits .filter { it.startsWith(\"a\") } .sortedBy { it } .map { it.toUpperCase() } .forEach { println(it) } 创建实例 val rectangle = Rectangle(5.0, 2.0) ","date":"2019-11-05","objectID":"/kotlin/:1:1","tags":["kotlin","语法"],"title":"Kotlin 常用语法","uri":"/kotlin/"},{"categories":["开发"],"content":"惯用语法 函数的默认参数 fun foo(a: Int = 0, b: String = \"\") { …… } 过滤 list val positives = list.filter { x -\u003e x \u003e 0 } 或者可以更短: val positives = list.filter { it \u003e 0 } 检测元素是否存在于集合中 if (\"john@example.com\" in emailsList) { …… } if (\"jane@example.com\" !in emailsList) { …… } 字符串内插 println(\"Name $name\") 类型判断 when (x) { is Foo //-\u003e …… is Bar //-\u003e …… else //-\u003e …… } 遍历 map/pair型list for ((k, v) in map) { println(\"$k-\u003e $v\") } k、v 可以改成任意名字。 使用区间 for (i in 1..100) { …… } // 闭区间：包含 100 for (i in 1 until 100) { …… } // 半开区间：不包含 100 for (x in 2..10 step 2) { …… } for (x in 10 downTo 1) { …… } if (x in 1..10) { …… } 只读 list val list = listOf(\"a\", \"b\", \"c\") 只读 map val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3) 访问 map println(map[\"key\"]) map[\"key\"] = value 延迟属性 val p: String by lazy { // 计算该字符串 } 扩展函数 fun String.spaceToCamelCase() { …… } \"Convert this to camelcase\".spaceToCamelCase() 创建单例 object Resource { val name = \"Name\" } If not null 缩写 val files = File(\"Test\").listFiles() println(files?.size) If not null and else 缩写 val files = File(\"Test\").listFiles() println(files?.size ?: \"empty\") if null 执行一个语句 val values = …… val email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\") 在可能会空的集合中取第一元素 val emails = …… // 可能会是空集合 val mainEmail = emails.firstOrNull() ?: \"\" if not null 执行代码 val value = …… value?.let { …… // 代码会执行到此处, 假如data不为null } 映射可空值（如果非空的话） val value = …… val mapped = value?.let { transformValue(it) } ?: defaultValue // 如果该值或其转换结果为空，那么返回 defaultValue。 返回 when 表达式 fun transform(color: String): Int { return when (color) { \"Red\" -\u003e 0 \"Green\" -\u003e 1 \"Blue\" -\u003e 2 else -\u003e throw IllegalArgumentException(\"Invalid color param value\") } } “try/catch”表达式 fun test() { val result = try { count() } catch (e: ArithmeticException) { throw IllegalStateException(e) } // 使用 result } “if”表达式 fun foo(param: Int) { val result = if (param == 1) { \"one\" } else if (param == 2) { \"two\" } else { \"three\" } } 返回类型为 Unit 的方法的 Builder 风格用法 fun arrayOfMinusOnes(size: Int): IntArray { return IntArray(size).apply { fill(-1) } } 单表达式函数 fun theAnswer() = 42 等价于 fun theAnswer(): Int { return 42 } 单表达式函数与其它惯用法一起使用能简化代码，例如和 when{: .keyword } 表达式一起使用： fun transform(color: String): Int = when (color) { \"Red\" -\u003e 0 \"Green\" -\u003e 1 \"Blue\" -\u003e 2 else -\u003e throw IllegalArgumentException(\"Invalid color param value\") } 对一个对象实例调用多个方法 （with） class Turtle { fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double) } val myTurtle = Turtle() with(myTurtle) { // 画一个 100 像素的正方形 penDown() for(i in 1..4) { forward(100.0) turn(90.0) } penUp() } 配置对象的属性（apply） val myRectangle = Rectangle().apply { length = 4 breadth = 5 color = 0xFAFAFA } 这对于配置未出现在对象构造函数中的属性非常有用。 Java 7 的 try with resources val stream = Files.newInputStream(Paths.get(\"/some/file.txt\")) stream.buffered().reader().use { reader -\u003e println(reader.readText()) } 对于需要泛型信息的泛型函数的适宜形式 // public final class Gson { // …… // public \u003cT\u003e T fromJson(JsonElement json, Class\u003cT\u003e classOfT) throws JsonSyntaxException { // …… inline fun \u003creified T: Any\u003e Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java) 使用可空布尔 val b: Boolean? = …… if (b == true) { …… } else { // `b` 是 false 或者 null } 交换两个变量 var a = 1 var b = 2 a = b.also { b = a } TODO()：将代码标记为不完整 Kotlin 的标准库有一个 TODO() 函数，该函数总是抛出一个 NotImplementedError。 其返回类型为 Nothing，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载： fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\") ","date":"2019-11-05","objectID":"/kotlin/:1:2","tags":["kotlin","语法"],"title":"Kotlin 常用语法","uri":"/kotlin/"},{"categories":["安卓"],"content":"常规 adb tcpip 5555 //设置远程设备监听端口 adb connect ip:port //连接远程设备 adb -s 20b5c60c shell ifconfig wlan0 //查看 IP adb reconnect //重新连接设备 adb shell am start -n ｛package｝/.{activity} //启动程序 adb shell setprop persist.service.adb.tcp.port 5555 //设置系统重启后，远程设备监听端口 adb shell wifitest -z \"W 00:1f:2e:3d:4c:5b\" //设置 WI-FI MAC adb shell wifitest -z \"B 00:1f:2e:3d:4c:5b\" //设置 蓝牙 MAC ","date":"2019-10-10","objectID":"/adb/:0:1","tags":["adb","命令"],"title":"ADB 常用命令","uri":"/adb/"},{"categories":["系统"],"content":"Shadowsocks ","date":"2019-04-15","objectID":"/centos/:1:0","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"安装 yum install python-setuptools \u0026\u0026 easy_install pip pip install shadowsocks ","date":"2019-04-15","objectID":"/centos/:1:1","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"使用 ssserver -p 443 -k password -m rc4-md5 # 前台启动 sudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start # 后台启动 sudo ssserver -d stop # 停止 sudo less /var/log/shadowsocks.log # 查看日志 注：使用配置文件 创建配置文件 /etc/shadowsocks.json ，例如： { \"server\":\"my_server_ip\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"mypassword\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false } 前台运行： ssserver -c /etc/shadowsocks.json 后台运行： ssserver -c /etc/shadowsocks.json -d start #启动 ssserver -c /etc/shadowsocks.json -d stop #停止 ","date":"2019-04-15","objectID":"/centos/:1:2","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"BBR 加速 一键安装最新内核并开启 BBR 脚本 wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026\u0026 chmod +x bbr.sh \u0026\u0026 ./bbr.sh ","date":"2019-04-15","objectID":"/centos/:1:3","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"开机启动 创建 /etc/systemd/system/shadowsocks.service , 内容如下： [Unit] Description=Shadowsocks [Service] TimeoutStartSec=0 ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json [Install] WantedBy=multi-user.target 设置文件权限 chmod +x /etc/systemd/system/shadowsocks.service 设置开机启动 systemctl enable shadowsocks.service 测试服务 systemctl start shadowsocks # 启动 systemctl status shadowsocks # 查看状态 ","date":"2019-04-15","objectID":"/centos/:1:4","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"其他常用 ","date":"2019-04-15","objectID":"/centos/:2:0","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"修改密码 passwd ","date":"2019-04-15","objectID":"/centos/:2:1","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"firewall 命令 （centos 默认会开启防火墙，需要开启端口才能被访问） $firewall-cmd --state # 查看防火墙 $firewall-cmd --list-ports # 查看端口 $firewall-cmd --zone=public --add-port=80/tcp --permanent # 开启端口 $firewall-cmd --reload # 重启防火墙 ","date":"2019-04-15","objectID":"/centos/:2:2","tags":["centos","命令"],"title":"Centos 常用命令","uri":"/centos/"},{"categories":["系统"],"content":"常用命令 rm -rf a.txt ##删除 cp b.txt a.txt ##复制文件 mv a.txt b.txt ##修改文件名 nohup ping todev.cn \u0026 ## 后台任务 jobs -l ## 查看后台任务, num,pid kill %num ## 杀掉后台任务，根据编号 ps -aux | grep \"****\" ## 查看相关进程 kill pid ## 杀掉进程，根据pid ","date":"2019-04-15","objectID":"/linux/:1:0","tags":["linux","命令"],"title":"Linux 常用命令","uri":"/linux/"},{"categories":["系统"],"content":"设置文件权限 chmod 777 test.txt # 设置 test.txt 文件为所有用户都有读、写、执行权限 -rw------- (600) 只有拥有者有读写权限。 -rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。 -rwx------ (700) 只有拥有者有读、写、执行权限。 -rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。 -rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。 -rw-rw-rw- (666) 所有用户都有文件读、写权限。 -rwxrwxrwx (777) 所有用户都有读、写、执行权限。 ","date":"2019-04-15","objectID":"/linux/:1:1","tags":["linux","命令"],"title":"Linux 常用命令","uri":"/linux/"},{"categories":["系统"],"content":"环境配置 # 编辑 vi ~/.bash_profile # 更新 source ~/.bash_profile ","date":"2019-04-15","objectID":"/linux/:1:2","tags":["linux","命令"],"title":"Linux 常用命令","uri":"/linux/"},{"categories":["系统"],"content":"Mac ","date":"2019-04-15","objectID":"/mac/:1:0","tags":["mac","命令"],"title":"Mac 常用命令","uri":"/mac/"},{"categories":["系统"],"content":"用户环境变量 bash vim ~/.bash_profile export ANDROID_HOME=/Users/xxx/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools source .bash_profile zsh vim ~/.zshrc export ANDROID_HOME=/Users/xxx/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools source .zshrc ","date":"2019-04-15","objectID":"/mac/:1:1","tags":["mac","命令"],"title":"Mac 常用命令","uri":"/mac/"},{"categories":["系统"],"content":"apt ","date":"2019-04-15","objectID":"/ubuntu/:1:0","tags":["ubuntu","命令"],"title":"Ubuntu 常用命令","uri":"/ubuntu/"},{"categories":["系统"],"content":"常用命令 apt-cache search package # 搜索包 apt-cache show package # 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package # 安装包 sudo apt-get install package - - reinstall # 重新安装包 sudo apt-get -f install # 修复安装\"-f = ——fix-missing\" sudo apt-get remove package # 删除包 sudo apt-get remove package - - purge # 删除包，包括删除配置文件等 sudo apt-get update # 更新源 sudo apt-get upgrade # 更新已安装的包 sudo apt-get dist-upgrade # 升级系统 sudo apt-get dselect-upgrade # 使用 dselect 升级 apt-cache depends package # 了解使用依赖 apt-cache rdepends package # 是查看该包被哪些包依赖 sudo apt-get build-dep package # 安装相关的编译环境 apt-get source package # 下载该包的源代码 sudo apt-get clean \u0026\u0026 sudo apt-get autoclean # 清理无用的包 sudo apt-get check # 检查是否有损坏的依赖 ","date":"2019-04-15","objectID":"/ubuntu/:1:1","tags":["ubuntu","命令"],"title":"Ubuntu 常用命令","uri":"/ubuntu/"},{"categories":["系统"],"content":"常见问题 修改密码 sudo passwd root 中文乱码 locale # 查看是否中文 locale-gen zh_CN.GBK # 如果不是，添加中文字符集 vim /etc/environment # 配置环境 LANGUAGE=”zh_CN:zh:en_US:en” LANG=zh_CN.GBK source /etc/environment # 生效 ","date":"2019-04-15","objectID":"/ubuntu/:1:2","tags":["ubuntu","命令"],"title":"Ubuntu 常用命令","uri":"/ubuntu/"},{"categories":["系统"],"content":"开发环境 使用 Scoop 搭建开发环境 ######################################################### ################## Scoop Install ################# ######################################################### ##### Set ExecutionPolicy Set-ExecutionPolicy RemoteSigned -scope CurrentUser ##### Custom Path $env:SCOOP='D:\\wxiang\\Scoop' [environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User') iwr -useb get.scoop.sh | iex ##### Set Proxy scoop config proxy 127.0.0.1:1080 ##### GIT scoop install git git config --global user.name \"itwangxiang\" git config --global user.email \"itwangxiang@foxmail.com\" ##### Add Bucket scoop bucket add extras scoop bucket add nirsoft scoop bucket add java scoop bucket add jetbrains ######################################################### ################## App Install ################### ######################################################### ##### CLI tools scoop install sudo scoop install curl scoop install wget scoop install aria2 scoop install zip ## Config #scoop install concfg #concfg export console-backup.json #concfg import solarized-dark ## SSH #scoop install win32-openssh ##ssh-keygen ##cat ~/.ssh/id_rsa.pub | ssh root@wxiang.cc 'mkdir -p ~/.ssh; cat \u003e\u003e ~/.ssh/authorized_keys' ##### GUI Software ## scoop install vscode scoop install IntelliJ-IDEA-Ultimate ## Tool scoop install vim scoop install windows-terminal scoop install beyondcompare scoop install sublime-text scoop install postman #scoop install xmind8 # 思维导图 #scoop install jmeter # 压力测试 ##### SDK scoop install openjdk8-redhat ","date":"2019-04-15","objectID":"/windows/:1:0","tags":["windows","命令"],"title":"Windows 常用命令","uri":"/windows/"},{"categories":["开发"],"content":"基础 安装 window PATH environment # 临时设置环境 $Env:path += \";D:\\_SDK\\flutter\\bin\" # 授权系统执行脚本权限 $set-executionpolicy remotesigned # 为当前用户设置环境 $Add-Content -Path $Profile.CurrentUserAllHosts -Value '$Env:Path += \";D:\\_SDK\\flutter\\bin\"' ","date":"2019-03-05","objectID":"/flutter/:0:1","tags":["flutter"],"title":"Flutter 初体验","uri":"/flutter/"},{"categories":["帮助"],"content":"搜索技巧 Google 搜索帮助文档 完全匹配 - \"\" \"关键字\" \"最高的建筑\" 排除关键字 - - 关键字 -排除关键字 中国美食 -麻辣 组合搜索 - OR 关键字 OR 关键字 马拉松 OR 比赛 搜索特定网站 - site: 关键字 site:网址 美女 site:youtube.com 文件类型 - filetype: 关键字 filetype:文件类型 模糊匹配 - * 关键字*关键字 搜索 # 标签 - # #关键字 同义词 - ~ 关键字 ~同义关键字 关键词 - intitle ","date":"2019-03-05","objectID":"/google-search/:0:1","tags":["google","技巧"],"title":"Google 搜索技巧","uri":"/google-search/"},{"categories":["工具"],"content":" \u003ctype\u003e[optional scope]: \u003cdescription\u003e [optional body] [optional footer(s)] # head: \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e # - type: feat, fix, docs, style, refactor, test, chore # - scope: can be empty (eg. if the change is a global or difficult to assign to a single component) # - subject: start with verb (such as 'change'), 50-character line # # body: 72-character wrapped. This should answer: # * Why was this change necessary? # * How does it address the problem? # * Are there any side effects? # # footer: # - Include a link to the ticket, if any. # - BREAKING CHANGE # ","date":"2019-01-05","objectID":"/git-commit-message-specification/:0:0","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":"Header ","date":"2019-01-05","objectID":"/git-commit-message-specification/:1:0","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":"type: commit 的类别 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变 ","date":"2019-01-05","objectID":"/git-commit-message-specification/:1:1","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":"scope: commit 影响的范围 ","date":"2019-01-05","objectID":"/git-commit-message-specification/:1:2","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":"subject: commit 目的的简短描述 ","date":"2019-01-05","objectID":"/git-commit-message-specification/:1:3","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":"Body : 对本次 commit 的详细描述 ","date":"2019-01-05","objectID":"/git-commit-message-specification/:2:0","tags":["git","规范"],"title":"Git Commit Message 规范","uri":"/git-commit-message-specification/"},{"categories":["工具"],"content":" 摘录 - 常用 Git 命令清单 ","date":"2019-01-05","objectID":"/git/:0:0","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"关系图 ","date":"2019-01-05","objectID":"/git/:0:1","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 ","date":"2019-01-05","objectID":"/git/:0:2","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] ","date":"2019-01-05","objectID":"/git/:0:3","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"配置 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" # 缓存密钥 $ git config --global credential.helper store ","date":"2019-01-05","objectID":"/git/:0:4","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2019-01-05","objectID":"/git/:0:5","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... ","date":"2019-01-05","objectID":"/git/:0:6","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2019-01-05","objectID":"/git/:0:7","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] ","date":"2019-01-05","objectID":"/git/:0:8","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2019-01-05","objectID":"/git/:0:9","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2019-01-05","objectID":"/git/:0:10","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2019-01-05","objectID":"/git/:0:11","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"设置 Git 代理 设置 git config --global http.proxy http://127.0.0.1:1087 git config --global https.proxy https://127.0.0.1:1087 # 只对 github.com git config --global http.https://github.com.proxy http://127.0.0.1:1087 git config --global https.https://github.com.proxy https://127.0.0.1:1087 取消 git config --global --unset http.proxy git config --global --unset https.proxy # github.com git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy ","date":"2019-01-05","objectID":"/git/:0:12","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"设置 SSH 代理 # 这里的 -a none 是 NO-AUTH 模式，参见 https://bitbucket.org/gotoh/connect/wiki/Home 中的 More detail 一节 ProxyCommand connect -S 127.0.0.1:1080 -a none %h %p Host github.com User git Port 22 Hostname github.com # 注意修改路径为你的路径 IdentityFile \"C:\\Users\\bookey\\.ssh\\id_rsa\" TCPKeepAlive yes Host ssh.github.com User git Port 443 Hostname ssh.github.com # 注意修改路径为你的路径 IdentityFile \"C:\\Users\\bookey\\.ssh\\id_rsa\" TCPKeepAlive yes ","date":"2019-01-05","objectID":"/git/:0:13","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":"其它 # 生成一个可供发布的压缩包 $ git archive # 暂时忽略个别文件的变动 $ git update-index --assume-unchanged #忽略 $ git update-index --no-assume-unchanged # 取消忽略 ","date":"2019-01-05","objectID":"/git/:0:14","tags":["git","命令"],"title":"Git 常用命令","uri":"/git/"},{"categories":["工具"],"content":" vimtutor zh_CN 进入《Vim 使用教程》 ","date":"2019-01-01","objectID":"/vim/:0:0","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"模式 ESC 返回正常模式 v 进入可视模式 R 进入替换模式 ","date":"2019-01-01","objectID":"/vim/:1:0","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"进入与退出 进入: vim 文件名 \u003c回车\u003e 普通进入 sudo vim 文件名 \u003c回车\u003e 管理员进入 退去: :q! 取消所有改动并退出 :wq 保存改动并退出 ","date":"2019-01-01","objectID":"/vim/:2:0","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"命令和对象 许多改变文本的命令都由一个操作符和一个动作构成 在正常模式下修改命令的格式是： operator [number] motion 其中： operator 操作符，代表要做的事情，比如 d 代表删除 [number] 可以附加的数字，代表动作重复的次数 motion 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等 ","date":"2019-01-01","objectID":"/vim/:3:0","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"撤销 u 撤销之前的操作 U 撤销在一行中所做的改动 CTRL-R 撤销之前的撤销命令 ","date":"2019-01-01","objectID":"/vim/:3:1","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"滚屏 CTRL-f 向上滚动一屏 CTRL-b 向下滚动一屏 CTRL-d 向下滚动半屏 CTRL-u 向上滚动半屏 CTRL-e 向上滚动一行 CTRL-y 向下滚动一行 zz 将当前行移动到屏幕中央 zt 将当前行移动到屏幕顶部 zb 将当前行移动到屏幕底部 ","date":"2019-01-01","objectID":"/vim/:3:2","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"定位及文件状态 G 使当前光标跳转到文件最后一行 gg 使当前光标跳转到文件第一行 CTRL-G 显示当前编辑的文件名和文件中光标位置 ","date":"2019-01-01","objectID":"/vim/:3:3","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"移动 k 向上移动光标 j 向下移动光标 h 向左移动光标 l 向右移动光标 0 移动光标到行首 ^ 移动光标到行首-非空字符 $ 移动光标到行末 w 移动光标到下一个单词的开头 e 移动光标到下一个单词的末尾 b 移动光标到上一个单词的开头 ge 移动光标到上一个单词的开头 H 移动到屏幕顶部 L 移动到屏幕低部 :5 移动到第5行 5| 移动到第5列 ","date":"2019-01-01","objectID":"/vim/:3:4","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"插入 i 从当前光标之前插入 a 从当前光标之后插入 I 从当前光标所在行首处插入 A 从当前光标所在行的末尾插入 o 在光标下方新的一行插入 O 在光标上方新的一行插入 ","date":"2019-01-01","objectID":"/vim/:3:5","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"删除 x 删除当前光标字符 dw 删除当前光标至下一个单词 d$ 或 D 删除当前光标至整行的末尾 dd 删除整行 ","date":"2019-01-01","objectID":"/vim/:3:6","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"复制 v 进入可视模式，移动光标选择要复制的字符 y 复制高亮的文本 yw 复制一个单词 y$ 复制当前光标至整行的末尾 yy 复制当前光标所在行 ","date":"2019-01-01","objectID":"/vim/:3:7","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"置入 p 将最后一次删除的内容置入光标之后 ","date":"2019-01-01","objectID":"/vim/:3:8","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"更改 ch 以输入的文本替代前一个光标 cl 或 s 以输入的文本替代当前光标 cc 或 S 修改当前行 ce 以输入的文本替代光标所在单词的末尾 C 以输入的文本替代光标到所在行的末尾 ","date":"2019-01-01","objectID":"/vim/:3:9","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"替换 r [替换字符] 将当前光标所在位置的字符替换掉 R [替换字符…] 将当前光标所在位置的字符连续替换掉 :s/old/new 在一行内替换头一个字符串 old 为新的字符串 new :s/old/new/s 在一行内替换所有到字符串 old 为新的字符串 new :#,#s/old/new/g 在两行内替换所有到字符串 old 为新的字符串 new.其中 #,# 代表的是替换操作的若干行中首尾两行的行号 :%s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new :%s/old/new/gc 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/^/hello/g 在每一行开头加入hello :%s/$/hello/g 在每一行结尾加入hello :%s/ *$//g 删除每行末尾无用空格 ","date":"2019-01-01","objectID":"/vim/:3:10","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"搜索类 /kim 在当前文件中从上到下查找 kim /\\cKim 在当前文件中从上到下查找 Kim 不区分大小写 /jo[ha]n 搜索 john 或 joan ?kim 在当前文件中从下到上查找 kim * 搜索当前光标下单词 n 查找同上一次的字符串 N 反向查找同上一次的字符串 ? [搜索字符] 在当前文件中逆向查找该字符串 CTRL-O 回到你之前的位置 CTRL-I 会跳转到较新到位置 ","date":"2019-01-01","objectID":"/vim/:3:11","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"大小写 Vu 整行小写 VU 整行大写 veu 单词小写 veU 单词大写 ","date":"2019-01-01","objectID":"/vim/:3:12","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"标记 m{a-z} 标记光标所在的位置，局部标记，只用于当前文件 `{a-z} 移动到标记位置 ","date":"2019-01-01","objectID":"/vim/:3:13","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"匹配命令 % 将光标放在)、]、},按下%会自动匹配对应到字符 ","date":"2019-01-01","objectID":"/vim/:3:14","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"自动补全 \u003cTAB\u003e 自己补全一个 CTRL-D 查看有可能的补全结果 ","date":"2019-01-01","objectID":"/vim/:3:15","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"外部命令 :!command 显示外部命令 command :w FILENAME 将当前编辑文件保存到名为 FILENAME 的文件中 :r FILENAME 提取磁盘文件 FILENAME 并将其插入当前文件的光标位置后面 ","date":"2019-01-01","objectID":"/vim/:3:16","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"设置类命令的选项 :set ic 忽略大小写 noic 禁用忽略大小写 is 查找短语时显示部分匹配 hls 高亮显示所有的匹配短语 ","date":"2019-01-01","objectID":"/vim/:3:17","tags":["vim","命令"],"title":"Vim 常用命令","uri":"/vim/"},{"categories":["工具"],"content":"安装 # 脚本安装 ## 官方 $curl -sSL https://get.docker.com/ | sh ## 阿里云 $curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun # centos $yum update ## 卸载旧版本 $sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ## 使用仓库安装 ### 设置一个仓库 $sudo yum install -y yum-utils #### 官方 $sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #### 阿里云 $sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ### 安装最新的引擎 $sudo yum install docker-ce docker-ce-cli containerd.io ### 启动 docker $sudo systemctl start docker ### 设置随系统重启 $sudo systemctl enable docker ### 设置加速代理（https://mirror.ccs.tencentyun.com）（https://78hmjqgm.mirror.aliyuncs.com） $sudo mkdir -p /etc/docker $sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://mirror.ccs.tencentyun.com\"] } EOF $sudo systemctl daemon-reload $sudo systemctl restart docker ### 设置 docker compose https://docs.docker.com/compose/install/ $sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose $sudo chmod +x /usr/local/bin/docker-compose ","date":"2018-12-05","objectID":"/docker/:1:0","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Command ","date":"2018-12-05","objectID":"/docker/:2:0","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Exec docker exec [OPTIONS] CONTAINER COMMAND [ARG…] ","date":"2018-12-05","objectID":"/docker/:2:1","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Log docker logs [OPTIONS] CONTAINER options --details --follow , -f - 跟踪日志输出 --tail - 从日志末尾开始显示的行数 --since - 显示自时间戳记以来的日志（例如2013-01-02T13：23：37）或相对时间（例如42m，持续42分钟） $docker logs --since=\"2022-05-07T13:23:00\" --until \"2022-05-07T14:00:00\" xxx ","date":"2018-12-05","objectID":"/docker/:2:2","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"部署示例 ","date":"2018-12-05","objectID":"/docker/:3:0","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Network $sudo docker network create -d bridge --subnet 172.25.0.0/24 mydev; ","date":"2018-12-05","objectID":"/docker/:3:1","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Mongodb # 部署 mongodb://admin:d*w*4**@ip $sudo docker run -d --restart=always --net mydev --name mongo -h mongo -v mongo-db:/data/db -v mongo-configdb:/data/configdb -p 27017:27017 \\ -e MONGO_INITDB_ROOT_USERNAME=admin \\ -e MONGO_INITDB_ROOT_PASSWORD=****** \\ mongo # shell 连接, 并登录 $docker exec -it mongo mongo admin $db.auth('admin','******') # 设置 db 密码 $use wxiang $db.createUser({ user: 'wxiang', // 用户名 pwd: '******', // 密码 roles:[{ role: 'dbOwner', // 角色 db: 'wxiang' // 数据库 }] }) ","date":"2018-12-05","objectID":"/docker/:3:2","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Mysql # 部署 $sudo docker run -d --restart=always --net mydev --name mysql -h mysql \\ -v mysql-data:/var/lib/mysql \\ -v mysql-config:/etc/mysql/conf.d \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=****** \\ mysql # shell 链接 $docker exec -it mysql mysql -uroot -p # 允许 root 远程登录 $grant all privileges on *.* to 'root'@'%' identified by '******' with grant option; # 设置 db 密码 $CREATE USER 'nacos'@'%' IDENTIFIED BY '******'; $GRANT ALL ON nacos.* TO 'nacos'@'%'; $flush privileges; # 设置内存 $docker exec -it mysql bash $vi /etc/mysql/conf.d/docker.cnf performance_schema_max_table_instances=400 table_definition_cache=400 table_open_cache=256 performance_schema = off ","date":"2018-12-05","objectID":"/docker/:3:3","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Redis # 部署 $sudo docker run -d --restart=always --net mydev --name redis -h redis -v redis-data:/data -p 6379:6379 \\ redis \\ --requirepass \"******\" # shell 链接 $docker exec -it redis redis-cli -a ****** ","date":"2018-12-05","objectID":"/docker/:3:4","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"Nacos # 部署 $sudo docker run -d --restart=always --net mydev --name nacos -h nacos -p 8848:8848 \\ -e MODE=standalone \\ -e PREFER_HOST_MODE=hostname \\ -e SPRING_DATASOURCE_PLATFORM=mysql \\ -e MYSQL_SERVICE_HOST=mysql \\ -e MYSQL_SERVICE_PORT=3306 \\ -e MYSQL_SERVICE_DB_NAME=nacos \\ -e MYSQL_SERVICE_USER=****** \\ -e MYSQL_SERVICE_PASSWORD=****** \\ -e JVM_XMS=64m \\ -e JVM_XMX=64m \\ -e JVM_XMN=16m \\ -e JVM_MS=8m \\ -e JVM_MMS=8m \\ nacos/nacos-server ","date":"2018-12-05","objectID":"/docker/:3:5","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["工具"],"content":"jenkins $sudo docker run -d --restart=always --net mydev --name jenkins -h jenkins \\ -p 50080:8080 \\ -p 50000:50000 \\ -e JENKINS_JAVA_OPTIONS='-XX:MaxPermSize=512m -Djava.awt.headless=true' \\ -v jenkins-data:/var/jenkins_home \\ -v jenkins-home:/home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ jenkinsci/blueocean ","date":"2018-12-05","objectID":"/docker/:3:6","tags":["docker","部署"],"title":"Docker 部署记录","uri":"/docker/"},{"categories":["开发"],"content":"交叉编译 Mac 下编译 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Linux 下编译 # mac CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go # windows CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Windows 下编译 # mac SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go #linux SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go ","date":"2018-04-18","objectID":"/golang/:0:1","tags":["go","命令"],"title":"Golang 编译命令","uri":"/golang/"},{"categories":["工具"],"content":"安装/卸载 ","date":"2018-04-18","objectID":"/nginx/:1:0","tags":["nginx","部署"],"title":"Nginx 部署记录","uri":"/nginx/"},{"categories":["工具"],"content":"ubuntu 安装 #!apt-get install nginx 卸载 apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。 apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。 apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。 apt-get remove nginx-full nginx-common #卸载删除两个主要的包。 ","date":"2018-04-18","objectID":"/nginx/:1:1","tags":["nginx","部署"],"title":"Nginx 部署记录","uri":"/nginx/"},{"categories":["工具"],"content":"centos 安装/卸载 ## 安装 yum install nginx systemctl start nginx.service ## 卸载 systemctl stop nginx.service systemctl disable nginx.service rm -rf /usr/sbin/nginx rm -rf /etc/nginx rm -rf /etc/init.d/nginx yum remove nginx ","date":"2018-04-18","objectID":"/nginx/:1:2","tags":["nginx","部署"],"title":"Nginx 部署记录","uri":"/nginx/"},{"categories":["工具"],"content":"常用配置 ","date":"2018-04-18","objectID":"/nginx/:2:0","tags":["nginx","部署"],"title":"Nginx 部署记录","uri":"/nginx/"},{"categories":["工具"],"content":"设置 HTTPS 将 SSL 签名保存 /etc/nginx/certs/* 新建 /etc/nginx/conf.d/***.conf 内容如下： server { listen 443; server_name www.todev.cn; access_log /var/log/nginx/www.todev.cn.access.log; ssl on; ssl_certificate certs/www.todev.cn.crt; ssl_certificate_key certs/www.todev.cn.key; location / { proxy_pass http://127.0.0.1:3000/; } } server { listen 80; server_name todev.cn; return 301 https://www.todev.cn$request_uri; } ","date":"2018-04-18","objectID":"/nginx/:2:1","tags":["nginx","部署"],"title":"Nginx 部署记录","uri":"/nginx/"},{"categories":["安卓"],"content":" 3.1.1 ","date":"2017-03-05","objectID":"/eventbus/:0:0","tags":["EventBus","源码"],"title":"EventBus 源码分析","uri":"/eventbus/"},{"categories":["安卓"],"content":"使用 定义事件 public static class MessageEvent { /* Additional fields if needed */ } 准备订阅者：声明并注释您的订阅方法，可选择指定一个线程模式 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) {/* Do something */}; 注册和注销您的订阅者 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } 发布事件 EventBus.getDefault().post(new MessageEvent()); ","date":"2017-03-05","objectID":"/eventbus/:0:1","tags":["EventBus","源码"],"title":"EventBus 源码分析","uri":"/eventbus/"},{"categories":["安卓"],"content":"简单流程 Register subscriber (注册订阅者) post (发送事件) -\u003e invoke @Subscribe (执行订阅方法) Unregister subscriber(注销订阅者) ","date":"2017-03-05","objectID":"/eventbus/:0:2","tags":["EventBus","源码"],"title":"EventBus 源码分析","uri":"/eventbus/"},{"categories":["安卓"],"content":"基础篇 ","date":"2017-01-05","objectID":"/android/:1:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"四大组件 Activity 生命周期 onCreate() onStart() onResume() onPause() onStop() onDestory() 启动模式 standard singleTop singleTask singleInstance Service startService onCreate() onStartCommand() onStart() onDestroy() bindService bindService() onCreate() //IBinder onBind(Intent intent)() unBindService() onDestroy() BroadcastReceiver 作用：从 Android 系统和其他 Android 应用程序发送或接收广播消息 注册方式：静态/动态 类型 普通广播 Normal Broadcast 系统广播 System Broadcast 有序广播 Ordered Broadcast 粘性广播 Sticky Broadcast 应用内广播 Local Broadcast Content Provider ","date":"2017-01-05","objectID":"/android/:1:1","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"布局 LinearLayout RelativeLayout FrameLayout TableLayout ","date":"2017-01-05","objectID":"/android/:1:2","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"View SurfaceView 双缓冲机制 子线程绘制 TextureView TextureView可用于显示内容流。 例如，这样的内容流可以是视频或OpenGL场景。 内容流可以来自应用程序的进程，也可以来自远程进程 VideoView WebView ","date":"2017-01-05","objectID":"/android/:1:3","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"其他 AlertDialog,popupWindow,Activity 的区别 Application 和 Activity 的 Context 对象的区别 BroadcastReceiver，LocalBroadcastReceiver 的区别 ","date":"2017-01-05","objectID":"/android/:1:4","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"原理篇 ","date":"2017-01-05","objectID":"/android/:2:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"View 绘制 measure MeasureSpec UNSPECIFIED - 未明确模式 EXACTLY - 精确模式 AT_MOST - 最多模式 layout draw onDraw(Canvas canvas) ","date":"2017-01-05","objectID":"/android/:2:1","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"事件传递机制 ViewGroup dispatchTouchEvent() onInterceptTouchEvent() == true onTouchListener.onTouch() onTouchEvent() onClick() View dispatchTouchEvent() onTouchListener.onTouch() onTouchEvent() onClick() View 滑动冲突 外部拦截法 public boolean onInterceptTouchEvent(MotionEvent event) { boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: { intercepted = false; break; } case MotionEvent.ACTION_MOVE: { if (满足父容器的拦截要求) { intercepted = true; } else { intercepted = false; } break; } case MotionEvent.ACTION_UP: { intercepted = false; break; } default: break; } mLastXIntercept = x; mLastYIntercept = y; return intercepted; } 内部拦截法 示例 子 View public boolean dispatchTouchEvent(MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: { parent.requestDisallowInterceptTouchEvent(true); break; } case MotionEvent.ACTION_MOVE: { int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) { parent.requestDisallowInterceptTouchEvent(false); } break; } case MotionEvent.ACTION_UP: { break; } default: break; } mLastX = x; mLastY = y; return super.dispatchTouchEvent(event); } 父 View public boolean onInterceptTouchEvent(MotionEvent event) { int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) { return false; } else { return true; } } 注意点： 内部拦截法要求父View不能拦截ACTION_DOWN事件，由于ACTION_DOWN不受FLAG_DISALLOW_INTERCEPT标志位控制，一旦父容器拦截ACTION_DOWN那么所有的事件都不会传递给子View。 滑动策略的逻辑放在子View的dispatchTouchEvent方法的ACTION_MOVE中，如果父容器需要获取点击事件则调用 parent.requestDisallowInterceptTouchEvent(false)方法，让父容器去拦截事件。 ","date":"2017-01-05","objectID":"/android/:2:2","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"Handler post 流程 等待消息：Looper.loop(); 消息入队： Handler.sendMessage(msg) Looper.MessageQueue.enqueueMessage(msg) 处理消息：Looper.loop(); 循环 MessageQueue.next() 调用 msg.target.dispatchMessage(msg) 消息出队： Handler.dispatchMessage(msg) Handler.handleMessage(msg) postDelayed 流程 消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大 Looper.loop() 通过 MessageQueue 中的 next() 去取消息 next() 中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会阻塞，不返回给 Looper message，知道时间到了，返回给 message 如果在阻塞中有新的消息插入到链表头部则唤醒线程 Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用 MessageQueen 的 next() 方法，如果刚刚的延迟消息还是时间未到，则计算时间继续阻塞 ","date":"2017-01-05","objectID":"/android/:2:3","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"AsyncTask 官网 AsyncTask 可以正确，方便地使用 UI 线程。此类允许您执行后台操作并在 UI 线程上发布结果，而无需操作线程和/或处理程序 ","date":"2017-01-05","objectID":"/android/:2:4","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"ActivityThread 它管理应用程序进程中主线程的执行，按照活动管理器的请求调度和执行活动、广播和其他操作 LauncherActivity 通过 Binder 进程间通信的方式将应用的信息通过 Intent 的方式传递给 AMS ，由 AMS 进行调度。 如果系统中不存在该进程时，AMS 将会请求 Zygote 服务去 fork 一个子进程，成功后返回一个 pid 给 AMS，并由 AndroidRuntime 机制调起 ActivityThread 中的 main() 方法。 紧接着，应用程序的 Main Looper 被创建，ActivityThread 被实例化成为对象并将 Application 的信息以进程间通信的方式再次回馈给 AMS。 AMS 接收到客户端发来的请求数据之后，首先将应用程序绑定，并启动应用程序的 Activity，开始执行 Activity 的生命周期 ","date":"2017-01-05","objectID":"/android/:2:5","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"内存泄露 场景 单例 匿名内部类 Context Handler Cursor，Stream WebView 排查工具 dumpsys adb shell dumpsys meminfo \u003cpackageName\u003e LeakCanary ","date":"2017-01-05","objectID":"/android/:2:6","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"内存溢出 - OOM 原因 内存泄露 内存占用过多的对象 ","date":"2017-01-05","objectID":"/android/:2:7","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"ThreadLocal ","date":"2017-01-05","objectID":"/android/:2:8","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"LruCache 缓存策略 包含对有限数量值的强引用的缓存。每次访问一个值时，它都会移动到队列的头部。将值添加到完整缓存时，该队列末尾的值将被逐出，并且可能符合垃圾回收的条件 原理： LruCache 中维护了一个 LinkedHashMap 集合并将其设置顺序排序。 当调用 put() 方法时，就会在集合中添加元素，并调用 trimToSize() 判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。 当调用 get() 方法访问缓存对象时，就会调用 LinkedHashMap 的 get() 方法获得对应集合元素，同时会更新该元素到队头 ","date":"2017-01-05","objectID":"/android/:2:9","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"屏幕刷新机制 Android 应用程序调用 SurfaceFlinger 服务把经过测量、布局和绘制后的 Surface 渲染到显示屏幕上 参考资料 Android 显示原理简介 ","date":"2017-01-05","objectID":"/android/:2:10","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"优化篇 内存优化 UI 优化 网络优化 启动优化 电量优化 参考资料 Android 性能优化全方面解析 ","date":"2017-01-05","objectID":"/android/:3:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"视频篇 ","date":"2017-01-05","objectID":"/android/:4:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"关键术语和概念 视频 - 泛指将一系列的静态影像以电信号方式加以捕捉、纪录、处理、存储、发送与重现的各种技术 帧率 - 用于测量显示帧数的量度 单位： FPS（每秒显示帧数） - 一般来说 FPS 用于描述影片、电子绘图或游戏每秒播放多少帧 Hz（赫兹） - 每一秒周期性事件发生的次数 视觉暂留 - 如果所看画面之帧率高于每秒约10至12帧的时候，就会认为是连贯的 长宽比 - 是用来描述影音画面与画面元素的比例 常见的比例 - 4:3 / 16:9 封装格式 - 压缩过的视频数据和音频数据打包成一个文件的规范 AVI、RMVB、MKV、ASF、WMV、MP4、3GP、FLV 编解码 编码 - 对视频进行压缩 视频编码格式 - H264、Xvid 音频编码格式 - MP3、AAC 解码 - 对视频进行解压缩 音画同步 将视频同步到音频上 将音频同步到视频上 将视频和音频同步外部的时钟上 RTC - 实时通信 采集 前处理 编码 传输 解码 后处理 缓冲 渲染 ","date":"2017-01-05","objectID":"/android/:4:1","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"解码 硬解 - 硬件解码是图形芯片厂商提出的用GPU资源解码视频流的方案 MediaPlayer 代表播放器 - Android 自带的 VideoView MediaCodec 代表播放器 - Google 的 ExoPlayer 软解 - 相对于硬件解码，传统的软件解码是用CPU承担解码工作 FFmpeg 代表播放器 - Bilibili 的 ijkplayer ","date":"2017-01-05","objectID":"/android/:4:2","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"网络篇 ","date":"2017-01-05","objectID":"/android/:5:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"外设篇 ","date":"2017-01-05","objectID":"/android/:6:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"低功耗蓝牙(Bluetooth Low Energy) 关键术语和概念 通用属性配置文件 Generic Attribute Profile (GATT) - GATT 配置文件是一种通用规范，内容针对在 BLE 链路上发送和接收称为“属性”的简短数据片段 属性协议 Attribute Protocol (ATT) — 属性协议 (ATT) 是 GATT 的构建基础，二者的关系也被称为 GATT/ATT 特征 Characteristic — 特征包含一个值和 0 至 n 个描述特征值的描述符 描述符 Descriptor — 描述符是描述特征值的已定义属性 服务 Service - 服务是一系列特征 使用流程 设置 BLE 获取 BluetoothAdapter 启用蓝牙 val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE) startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT) 查找 BLE 设备 方法 startLeScan(BluetoothAdapter.LeScanCallback) - 查找 BLE 设备 startLeScan(UUID[], BluetoothAdapter.LeScanCallback) - 扫描特定类型的外围设备 注意事项(由于扫描非常耗电) 找到所需设备后，立即停止扫描 绝对不进行循环扫描，并设置扫描时间限制 Code private var mScanning: Boolean = false //返回扫描结果 private val leScanCallback = BluetoothAdapter.LeScanCallback { device, rssi, scanRecord -\u003e runOnUiThread { //todo } } //在预定义的扫描时间段后停止扫描 handler.postDelayed({ mScanning = false bluetoothAdapter.stopLeScan(leScanCallback) }, 10000) mScanning = true bluetoothAdapter.startLeScan(leScanCallback) 连接 GATT 服务器 方法 BluetoothGatt connectGatt (Context context, boolean autoConnect, BluetoothGattCallback callback) Code private val gattCallback = object : BluetoothGattCallback() { override fun onConnectionStateChange( gatt: BluetoothGatt, status: Int, newState: Int ) { } // New services discovered override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) { when (status) { BluetoothGatt.GATT_SUCCESS -\u003e broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED) else -\u003e Log.w(TAG, \"onServicesDiscovered received: $status\") } } // Result of a characteristic read operation override fun onCharacteristicRead( gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int ) { when (status) { BluetoothGatt.GATT_SUCCESS -\u003e { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic) } } } // Characteristic notification override fun onCharacteristicChanged( gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic ) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic) } } 读取 BLE 属性 接收 GATT 通知 - setCharacteristicNotification() 关闭客户端应用 - close() ","date":"2017-01-05","objectID":"/android/:6:1","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"串口通信 android-serialport-api SerialPort - 获取串口的类(其实就是获取输入输出流) public SerialPort(File device, int baudrate, int flags) 参数 device - 要操作的文件对象 baudrate - 波特率 flags - 文件操作的标志 流程 JNI - FileDescriptor open(String path, int baudrate, int flags) C - int open(const char * pathname, int flags) pathname - 指向欲打开的文件路径字符串 flags - 文件的打开打开方式: O_RDONLY 以只读方式打开文件O_WRONLY 以只写方式打开文件O_RDWR 以可读写方式打开文件 return 若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1 读数据 - getInputStream() class ReadThread extends Thread { @Override public void run() { super.run(); while(!isInterrupted()) { int size; try { byte[] buffer = new byte[64]; if (getInputStream() == null) return; size = getInputStream().read(buffer); if (size \u003e 0) { onDataReceived(buffer, size); } } catch (IOException e) { e.printStackTrace(); return; } } } } 写数据 - getOutputStream() String commandStr = \"\"; FileOutputStream mOutputStream = getOutputStream(); byte[] text = StringUtils.hexStringToBytes(commandStr); try { mOutputStream.write(text); mOutputStream.flush(); } catch (IOException e) { e.printStackTrace(); } SerialPortFinder - 获取硬件地址的类 常见问题 包名 - android_serialport_api 写入权限时，/system/xbin/su or /system/bin/su 设备需要 Root 权限 ","date":"2017-01-05","objectID":"/android/:6:2","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"开源篇 ","date":"2017-01-05","objectID":"/android/:7:0","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"OkHttp - 官网 适用于 Android 和 Java 应用程序的 HTTP + HTTP/2 客户端 OkHttp 支持同步调用和异步调用 OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持，这使得对同一个主机发出的所有请求都可以共享相同的套接字连接 如果 HTTP/2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提高效率 OkHttp 提供了对 GZIP 的默认支持来降低传输内容的大小 OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求 当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址 ","date":"2017-01-05","objectID":"/android/:7:1","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"Retrofit - 官网 适用于 Android 和 Java 的类型安全的 HTTP 客户端 默认基于 OkHttp 封装的一套 RESTful 网络请求框架 通过注解直接配置请求 使用不同 Json Converter 来序列化数据 提供对 RxJava 的支持 ","date":"2017-01-05","objectID":"/android/:7:2","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"Glide - 官网 Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动 Glide 支持拉取，解码和展示视频快照，图片，和 GIF 动画 Glide 使用简明的流式语法 API ","date":"2017-01-05","objectID":"/android/:7:3","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"ButterKnife - 官网 将 Android 视图和回调绑定到字段和方法 通过在字段上使用 @BindView 消除 findViewById 回调 在列表或数组中组合多个视图。一次性使用操作，设置器或属性操作它们 通过使用@OnClick和其他方法注释方法来消除侦听器的匿名内部类 通过在字段上使用资源注释来消除资源查找 ","date":"2017-01-05","objectID":"/android/:7:4","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"Rxjava - 官网 RxJava - JVM 的 Reactive Extensions - 一个使用 Java VM 的可观察序列组成异步和基于事件的程序的库 基于事件流的链式调用、逻辑简洁 \u0026 使用简单 扩展了观察者模式，以支持数据/事件序列，并增加了操作符，他可以将将序列清晰的组合在一起的 ","date":"2017-01-05","objectID":"/android/:7:5","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"Logger - 官网 简单，漂亮，功能强大的 android 记录器 ","date":"2017-01-05","objectID":"/android/:7:6","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"EventBus - 官网 源码分析 适用于 Android 和 Java 的事件总线，可简化 Activities, Fragments, Threads, Services 等之间的通信。减少代码，提高质量 ","date":"2017-01-05","objectID":"/android/:7:7","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["安卓"],"content":"多渠道打包 AndroidMultiChannelBuildTool ","date":"2017-01-05","objectID":"/android/:7:8","tags":["大纲"],"title":"Android 开发大纲","uri":"/android/"},{"categories":["开发"],"content":"集合 ","date":"2016-08-25","objectID":"/java/:1:0","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"非线程安全集合 List: 有序集合 ArrayList 数据结构：基于泛型数组 特点：查询速度快，增删速度慢 LinkedList 数据结构：基于链表结构 特点：查询速度慢，增删速度快 Map: 将键映射到值的双列集合 HashMap 数据结构： 基于哈希表 特点：存取无序 源码 DEFAULT_INITIAL_CAPACITY 默认为 16 MAXIMUM_CAPACITY 默认为 2 的 30 次幂 DEFAULT_LOAD_FACTOR 默认负载因子 0.75 每次会扩容长度为以前的2倍 TreeMap 有序 数据结构 -\u003e 基于红黑树 LinkedHashMap 数据结构： 基于链表和哈希表 特点：存取有序 EnumMap: 特点：枚举类型作为键值的Map IdentityHashMap: 特点：使用 “==” 来比较引用 WeakHashMap: 特点：将键存储在 WeakReference 中 场景：用于数据缓存中 Set: 不能包含重复元素的集合 HashSet: 数据结构： 基于哈希表 特点：存取无序 TreeSet 数据结构： 基于二叉树 特点：排序 LinkedHashSet 数据结构： 基于链表和哈希表 特点：存取有序 EnumSet: 特点：值为枚举类型的Set BitSet Queue/Deque: 队列 ArrayDeque 特点：基于有首尾指针的数组（环形缓冲区） PriorityQueue 特点：基于优先级的队列 ","date":"2016-08-25","objectID":"/java/:1:1","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"线程安全集合 List CopyOnWriteArrayList 特点：避免了多线程操作的线程安全问题 原理：先复制，再操作，最后替换 场景：用在遍历操作比更新操作多的集合，比如 listeners / observers 集合 Queue/Deque ArrayBlockingQueue 特点：基于数组实现的一个有界阻塞队，大小不能重新定义 ConcurrentLinkedQueue 特点：基于链表实现的无界队列 DelayQueue LinkedBlockingQueue / LinkedBlockingDeque 特点：可选择有界或者无界基于链表的实现 LinkedTransferQueue 特点：基于链表的无界队列 SynchronousQueue 特点：有界队列 Map ConcurrentHashMap ConcurrentSkipListMap 并发有序 Set ConcurrentSkipListSet CopyOnWriteArraySet ","date":"2016-08-25","objectID":"/java/:1:2","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"并发 ","date":"2016-08-25","objectID":"/java/:2:0","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"线程 创建 继承 Thread 并重写 run() 方法 - ThreadExample.java public class ThreadExample extends Thread { // run() method contains the code that is executed by the thread. @Override public void run() { System.out.println(\"Inside : \" + Thread.currentThread().getName()); } public static void main(String[] args) { System.out.println(\"Inside : \" + Thread.currentThread().getName()); System.out.println(\"Creating thread...\"); Thread thread = new ThreadExample(); System.out.println(\"Starting thread...\"); thread.start(); } } 实现 Runnable 接口 - RunnableExample.java public class RunnableExample implements Runnable { public static void main(String[] args) { System.out.println(\"Inside : \" + Thread.currentThread().getName()); System.out.println(\"Creating Runnable...\"); Runnable runnable = new RunnableExample(); System.out.println(\"Creating Thread...\"); Thread thread = new Thread(runnable); System.out.println(\"Starting Thread...\"); thread.start(); } @Override public void run() { System.out.println(\"Inside : \" + Thread.currentThread().getName()); } } 内部类实现 - RunnableExampleAnonymousClass.java public class RunnableExampleAnonymousClass { public static void main(String[] args) { System.out.println(\"Inside : \" + Thread.currentThread().getName()); System.out.println(\"Creating Runnable...\"); Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Inside : \" + Thread.currentThread().getName()); } }; System.out.println(\"Creating Thread...\"); Thread thread = new Thread(runnable); System.out.println(\"Starting Thread...\"); thread.start(); } } 休眠 使用 sleep() 等待 使用 join() ","date":"2016-08-25","objectID":"/java/:2:1","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"线程池 Executors 框架 优点 线程创建 线程管理 任务提交和执行 方法 execute - 执行任务 submit - 提交任务 shutdown() - 停止接受新任务，等待先前提交的任务执行，然后终止执行程序 shutdownNow() - 中断正在运行的任务并立即关闭执行程序 Code - - ExecutorsExample.java import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ExecutorsExample { public static void main(String[] args) { System.out.println(\"Inside : \" + Thread.currentThread().getName()); System.out.println(\"Creating Executor Service with a thread pool of Size 2\"); ExecutorService executorService = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e { System.out.println(\"Executing Task1 inside : \" + Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException ex) { throw new IllegalStateException(ex); } }; Runnable task2 = () -\u003e { System.out.println(\"Executing Task2 inside : \" + Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException ex) { throw new IllegalStateException(ex); } }; Runnable task3 = () -\u003e { System.out.println(\"Executing Task3 inside : \" + Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException ex) { throw new IllegalStateException(ex); } }; System.out.println(\"Submitting the tasks for execution...\"); executorService.submit(task1); executorService.submit(task2); executorService.submit(task3); //executorService 会一直监听新的任务（即阻塞线程），直到关闭他为止 executorService.shutdown(); } } 线程池 简介：与 Runnable 或 Callable 任务分开存在的一堆工作线程，由 executorService 管理 机制：任务通过 Blocking Queue 提交到线程池 如果任务的数量大过活动线程数量，则会将他插入 Blocking Queue 中，一直等到有可用线程为止 如果 Blocking Queue 已满，则拒绝新任务 Code ScheduledExecutorsExample.java ScheduledExecutorsPeriodicExample.java Callable 与 Future 方法 cancel(): 尝试取消执行任务，如果成功取消则返回true，否则返回false cancel(boolean mayInterruptIfRunning): 当 mayInterruptIfRunning 为 true 时，则当前正在执行任务的线程将被中断，否则将允许正在进行的任务完成 isCancelled: 任务是否被取消 isDone: 任务是否已完成 Code - FutureAndCallableExample.java ","date":"2016-08-25","objectID":"/java/:2:2","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"死锁/活锁/饥饿锁 乐观锁/悲观锁 死锁 - 其中两个或多个线程永远被阻塞，互相等待 活锁 - 其中两个线程一直在让资源，都无法使用资源 饥饿锁 - 其他线程一直占用资源，导致永远获取不到资源 乐观锁 - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性 悲观锁 - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 ","date":"2016-08-25","objectID":"/java/:2:3","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["开发"],"content":"CountDownLatch/Semaphore CountDownLatch 作用 - 允许一个或多个线程等待，直到在其他线程中执行的一组操作完成 方法 await() await(long timeout, TimeUnit unit) countDown() Code private static int LATCH_SIZE = 5; private static CountDownLatch doneSignal; public static void main(String[] args) { try { doneSignal = new CountDownLatch(LATCH_SIZE); // 新建5个任务 for(int i=0; i\u003cLATCH_SIZE; i++) new InnerThread().start(); System.out.println(\"main await begin.\"); // \"主线程\"等待线程池中5个任务的完成 doneSignal.await(); System.out.println(\"main await finished.\"); } catch (InterruptedException e) { e.printStackTrace(); } } static class InnerThread extends Thread{ public void run() { try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \" sleep 1000ms.\"); // 将CountDownLatch的数值减1 doneSignal.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } } Semaphore - 信号量 方法 acquire() acquire(int permits) release() release(int permits) ","date":"2016-08-25","objectID":"/java/:2:4","tags":["java","大纲"],"title":"Java 开发大纲","uri":"/java/"},{"categories":["基础"],"content":" 相关书籍 HeadFirst_设计模式.pdf 设计模式_可复用面向对象软件的基础.pdf ","date":"2015-09-12","objectID":"/design-pattern/:0:0","tags":null,"title":"设计模式","uri":"/design-pattern/"},{"categories":["基础"],"content":"创建型 工厂方法模式 Factory Method Pattern UML 图 Code FactoryMethodPattern.java Java 中用例 java.util.Calendar 建造者模式 Builder Pattern 单例模式 Singleton Pattern ","date":"2015-09-12","objectID":"/design-pattern/:1:0","tags":null,"title":"设计模式","uri":"/design-pattern/"},{"categories":["基础"],"content":"结构型 ","date":"2015-09-12","objectID":"/design-pattern/:2:0","tags":null,"title":"设计模式","uri":"/design-pattern/"},{"categories":["基础"],"content":"行为型 ","date":"2015-09-12","objectID":"/design-pattern/:3:0","tags":null,"title":"设计模式","uri":"/design-pattern/"},{"categories":["基础"],"content":"数据结构 todo ","date":"2015-09-03","objectID":"/data-structure-algorithm/:1:0","tags":null,"title":"数据结构与算法","uri":"/data-structure-algorithm/"},{"categories":["基础"],"content":"算法 ","date":"2015-09-03","objectID":"/data-structure-algorithm/:2:0","tags":null,"title":"数据结构与算法","uri":"/data-structure-algorithm/"},{"categories":["基础"],"content":"排序算法 对一序列对象根据某个关键字进行排序 冒泡排序 public static void bubbleSort(int[] array) { for (int i = 0; i \u003c array.length; i++) for (int j = 0; j \u003c array.length - i - 1; j++) if (array[j + 1] \u003c array[j]) { int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; } } 选择排序 public static void selectionSort(int[] arr) { int min, temp; for (int i = 0; i \u003c arr.length; i++) { // 初始化未排序序列中最小数据数组下标 min = i; for (int j = i + 1; j \u003c arr.length; j++) { // 在未排序元素中继续寻找最小元素，并保存其下标 if (arr[j] \u003c arr[min]) { min = j; } } // 将未排序列中最小元素放到已排序列末尾 if (min != i) { temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; } } } 快速排序 public static void quickSort(int[] arr, int head, int tail) { if (head \u003e= tail || arr == null || arr.length \u003c= 1) { return; } int i = head, j = tail, pivot = arr[(head + tail) / 2]; while (i \u003c= j) { while (arr[i] \u003c pivot) { ++i; } while (arr[j] \u003e pivot) { --j; } if (i \u003c j) { int t = arr[i]; arr[i] = arr[j]; arr[j] = t; ++i; --j; } else if (i == j) { ++i; } } quickSort(arr, head, j); quickSort(arr, i, tail); } ","date":"2015-09-03","objectID":"/data-structure-algorithm/:2:1","tags":null,"title":"数据结构与算法","uri":"/data-structure-algorithm/"},{"categories":null,"content":" 欢迎来到我的个人站点 ","date":"2015-08-02","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"作者 须远 ","date":"2015-08-02","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"职业 软件架构师 / 软件攻城狮 ","date":"2015-08-02","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技术栈 数据库 mysql mongodb 后端 Java Golang Nodejs 前端 Racet \u0026 Redux Vue Ionic 移动 Android \u0026 Kotlin iOS \u0026 Swift \u0026 Swift UI ","date":"2015-08-02","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"联系方式 Email ","date":"2015-08-02","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"版权 除非特别说明，这里所有文章皆为原创 本站采用知识共享 4.0 许可协议进行版权许可，如需转载，请注明来源。 ","date":"2015-08-02","objectID":"/about/:0:5","tags":null,"title":"关于","uri":"/about/"},{"categories":["基础"],"content":"计算机网络 ","date":"2015-07-15","objectID":"/computer-network/:0:0","tags":null,"title":"计算机网络","uri":"/computer-network/"},{"categories":["基础"],"content":"todo 1 ","date":"2015-07-14","objectID":"/operating-system/:0:1","tags":null,"title":"计算机操作系统","uri":"/operating-system/"},{"categories":["基础"],"content":"计算机组成原理 ","date":"2015-07-14","objectID":"/computer-organization/:0:0","tags":null,"title":"计算机组成原理","uri":"/computer-organization/"},{"categories":["基础"],"content":"todo ","date":"2015-07-14","objectID":"/compilers-principles/:0:1","tags":null,"title":"计算机编译原理","uri":"/compilers-principles/"}]